#!/usr/bin/env ocaml
#use ".ocamlinit";;

(*
 * Homework 1
 *)
(* Exercise 1 *)
let l0 = []
let l1 = [5; 3; 1]
let l2 = [4; 2; 0]
let l3 = [10; 7; 6]
let l4 = [11; 9; 8]
;;

assert ([10; 10; 4; 3; 2; 1] = (merge ([10; 4; 2], [10; 3; 1])));
assert ([10; 3; 2; -2; -3; -10] = (merge ([3; -2; -10], [10; 2; -3])));
assert (merge (l0, l0) = l0);
assert (merge (l1, l0) = l1);
assert (merge (l0, l2) = l2);
assert (merge (l1, l2) = [5; 4; 3; 2; 1; 0]);
assert (merge (l2, l1) = [5; 4; 3; 2; 1; 0]);
assert (merge (l3, l4) = [11; 10; 9; 8; 7; 6]);
assert (merge (l4, l3) = [11; 10; 9; 8; 7; 6]);
assert (merge (l1, l4) = [11; 9; 8; 5; 3; 1]);
assert (merge (merge (l1, l2), l4) = [11; 9; 8; 5; 4; 3; 2; 1; 0]);
assert (merge (merge (l1, l2), merge (l4, l3)) = [11; 10; 9; 8; 7; 6; 5; 4; 3; 2; 1; 0]);

assert (merge ([], [5;4;3;2;1]) = [5;4;3;2;1]);
assert (merge ([10;8;6;4;2], []) = [10;8;6;4;2]);
assert (merge ([3;2;1], [6;5;4]) = [6;5;4;3;2;1]);
assert (merge ([5;3;1], [4;2]) = [5;4;3;2;1]);
assert (merge ([10;2;1], [10;4;3]) = [10;10;4;3;2;1]);
;;

(* Exercise 2 *)
let foo = fun n -> n * 2
let bar = fun n -> n * n
;;

assert (385 = sigma (1, 10, fun x -> x*x));
assert (0 = sigma (3, 1, fun x -> x*x));
assert (27 = sigma (3, 3, fun x -> x*x*x));
assert (385 = sigma (-10, -1, fun x -> x*x));
assert (sigma (3, 1, foo) = 0);
assert (sigma (4, 2, bar) = 0);
assert (sigma (8, 8, foo) = 16);
assert (sigma (3, 4, bar) = 25);
assert (sigma (1, 10, foo) = 110);
assert (sigma (1, 10, bar) = 5 * 7 * 11);
assert (sigma (5, 10, foo) = 90);
assert (sigma (1, 100, foo) = 10100);

assert (sigma (10, 10, fun x -> x) = 10);
assert (sigma (11, 10, fun x -> x) = 0);
assert (sigma (10, 5, fun x -> x) = 0);
assert (sigma (1, 10, fun x -> if x mod 2 = 0 then 1 else 0 ) = 5);
assert (sigma (1, 10, fun x -> x * x) = 385);
;;

(* Exercise 3 *)
let f1 = fun x -> 2 + x
let f2 = fun x -> fun y -> x * y
;;

assert (20 = (iter (10, (fun x->x+2))) 0);
assert (100 = (iter (100, (fun x->x+1))) 0);
assert (0 = (iter (10, (fun x->x))) 0);
assert ((iter (10, f1)) 3 = 23);
assert ((iter (2, f1)) 121 = f1 (f1 121));
assert ((iter (3, f1)) 177 = f1 (f1 (f1 177)));
assert ((iter (4, f2 1)) 44 = 44);
assert (((iter (2, f2 7)) 4 = f2 7 (f2 7 4)));

assert (iter(10, fun x -> x + 3) 100 = 130);
assert (iter(0, fun x -> x + 3) 200 = 200);
assert (iter (3, List.tl) [1;2;3;4;5;6] = [4;5;6]);
assert (iter (4, (fun s -> s ^ s)) "a" = "aaaaaaaaaaaaaaaa");
assert (iter (5, fun (x,y,z) -> (z, x, y)) (1,2,3) = (2, 3, 1));
;;

(* Exercise 4 *)
let f1 = TRUE
let f2 = FALSE
let f3 = NOT f1
let f4 = ANDALSO (NOT f2, ANDALSO (f3, f1))
let f5 = ORELSE (ORELSE (f3, f1), f4)
let f6 = IMPLY (f4, f5)
let f7 = IMPLY (f5, ORELSE (f4, FALSE))
let f8 = ORELSE (IMPLY (NOT f6, f2), ANDALSO (ORELSE (f3, NOT f4), NOT f7))
let f9 = LESS (NUM 1, NUM 2)
let fa = LESS (PLUS (NUM 1, NUM 2), MINUS (NUM 0, NUM 121))
let fb =
  LESS
    (MINUS
      (PLUS (NUM 5, MINUS (NUM 1, NUM 21)),
       MINUS (NUM 0, NUM 100)), NUM 2)
;;

assert (true = eval TRUE);
assert (false = eval FALSE);
assert (false = eval (NOT TRUE));
assert (true = eval (NOT FALSE));
assert (true = eval (ANDALSO (TRUE, TRUE)));
assert (false = eval (ANDALSO (TRUE, FALSE)));
assert (false = eval (ANDALSO (FALSE, TRUE)));
assert (false = eval (ANDALSO (FALSE, FALSE)));
assert (true = eval (ORELSE (TRUE, TRUE)));
assert (true = eval (ORELSE (TRUE, FALSE)));
assert (true = eval (ORELSE (FALSE, TRUE)));
assert (false = eval (ORELSE (FALSE, FALSE)));
assert (false = eval (IMPLY (TRUE, FALSE)));
assert (true = eval (IMPLY (TRUE, TRUE)));
assert (true = eval (IMPLY (FALSE, TRUE)));
assert (true = eval (IMPLY (FALSE, FALSE)));
assert (true = eval (LESS (NUM 3, NUM 5)));
assert (false = eval (LESS (NUM 3, NUM 3)));
assert (false = eval (LESS (NUM 3, NUM 1)));
assert (false = eval (LESS (PLUS (NUM 3, NUM 4), MINUS (NUM 5, NUM 1))));
assert (true = eval (LESS (PLUS (NUM 10, NUM 12), MINUS (NUM 10, NUM (-13)))));
assert (eval f1 = true);
assert (eval f2 = false);
assert (eval f3 = false);
assert (eval f4 = false);
assert (eval f5 = true);
assert (eval f6 = true);
assert (eval f7 = false);
assert (eval f8 = true);
assert (eval f9 = true);
assert (eval fa = false);
assert (eval fb = false);

assert (eval (IMPLY(FALSE, FALSE)) = true);
assert (eval (ANDALSO (ORELSE(TRUE, FALSE), NOT (IMPLY(TRUE, FALSE)))) = true);
assert ((eval (ANDALSO (TRUE, TRUE))) && (not (eval (ANDALSO (TRUE, FALSE)))) && (not (eval (ANDALSO (FALSE, TRUE)))) && (not (eval (ANDALSO (FALSE, FALSE)))) = true);
assert ((eval (ORELSE (TRUE, TRUE))) && (eval (ORELSE (TRUE, FALSE))) && (eval (ORELSE (FALSE, TRUE))) && (not (eval (ORELSE (FALSE, FALSE)))) = true);
assert ((eval (IMPLY (TRUE, TRUE))) && (not (eval (IMPLY (TRUE, FALSE)))) && (eval (IMPLY (FALSE, TRUE))) && (eval (IMPLY (FALSE, FALSE))) = true);
assert (eval (LESS (NUM 3, NUM 5)) = true);
assert (eval (LESS (PLUS (NUM 3, NUM 5), PLUS (NUM 1, NUM 2))) = false);
assert (eval (LESS (MINUS (NUM 3, NUM 5), MINUS (NUM 1, NUM 2))) = true);
assert (eval (ORELSE (LESS (PLUS (MINUS (NUM 3, NUM 2), NUM 9), NUM 10), FALSE)) = false);
assert (eval (IMPLY(LESS (NUM 1, NUM 0), ANDALSO(TRUE, ORELSE(NOT TRUE, LESS(NUM 2, NUM 1))))) = true);
;;

(* Exercise 5 *)
let one = SUCC ZERO
let three = SUCC (SUCC (SUCC ZERO))
let four = SUCC three
let rec nat_to_int (input: nat): int =
  match input with
  | ZERO -> 0
  | SUCC(i1) -> 1 + (nat_to_int i1)
let rec int_to_nat (input: int): nat =
  match input with
  | 0 -> ZERO
  | _ -> SUCC (int_to_nat (input - 1))
;;

assert (7 = nat_to_int (natadd (three, four)));
assert (0 = nat_to_int (natadd (ZERO, ZERO)));
assert (3 = nat_to_int (natadd (ZERO, three)));
assert (4 = nat_to_int (natadd (four, ZERO)));

assert (12 = nat_to_int (natmul (three, four)));
assert (0 = nat_to_int (natmul (ZERO, three)));
assert (0 = nat_to_int (natmul (four, ZERO)));
assert (0 = nat_to_int (natmul (ZERO, ZERO)));
assert (3 = nat_to_int (natmul (SUCC ZERO, three)));
assert (4 = nat_to_int (natmul (four, SUCC ZERO)));

assert (nat_to_int (natadd (int_to_nat 0, int_to_nat 0)) = 0);
assert (nat_to_int (natadd (int_to_nat 2, int_to_nat 0)) = 2);
assert (nat_to_int (natadd (int_to_nat 0, int_to_nat 3)) = 3);
assert (nat_to_int (natadd (int_to_nat 1, int_to_nat 5)) = 6);
assert (nat_to_int (natadd (int_to_nat 3, int_to_nat 3)) = 6);
assert (nat_to_int (natadd (int_to_nat 12, int_to_nat 7)) = 19);
assert (nat_to_int (natadd (int_to_nat 34, int_to_nat 19)) = 53);

assert (nat_to_int (natmul (int_to_nat 0, int_to_nat 0)) = 0);
assert (nat_to_int (natmul (int_to_nat 2, int_to_nat 0)) = 0);
assert (nat_to_int (natmul (int_to_nat 0, int_to_nat 3)) = 0);
assert (nat_to_int (natmul (int_to_nat 1, int_to_nat 5)) = 5);
assert (nat_to_int (natmul (int_to_nat 3, int_to_nat 3)) = 9);
assert (nat_to_int (natmul (int_to_nat 11, int_to_nat 7)) = 77);
assert (nat_to_int (natmul (int_to_nat 8, int_to_nat 12)) = 96);

assert (natadd (ZERO, ZERO) = ZERO);
assert (natadd (ZERO, (SUCC (SUCC ZERO))) = (SUCC (SUCC ZERO)));
assert (natadd ((SUCC (SUCC ZERO)), (SUCC (SUCC (SUCC ZERO)))) = (SUCC (SUCC (SUCC (SUCC (SUCC ZERO))))));
assert (natmul (ZERO, (SUCC (SUCC ZERO))) = ZERO);
assert (natmul ((SUCC (SUCC ZERO)), (SUCC (SUCC (SUCC ZERO)))) = (SUCC (SUCC (SUCC (SUCC (SUCC (SUCC ZERO)))))));
;;

(*
 * Homework 2
 *)
(* Exercise 1 *)
let zero = ZERO NIL
let one = MONE (ONE (ZERO NIL))
let four = ZERO (ZERO (MONE (ONE NIL)))
let m_five = ONE (MONE (ONE (MONE NIL)))
let m_one = (ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(ONE(MONE NIL))))))))))))))))))))))))))))))
;;

assert ( 0 = crazy2val zero);
assert ( 1 = crazy2val one);
assert ( 4 = crazy2val four);
assert (-5 = crazy2val m_five);
assert (-1 = crazy2val m_one);
;;

(* Exercise 3 *)
assert (checkMetro (AREA("a", STATION "a") ));
assert (checkMetro (AREA("a", AREA("a", STATION "a")) ));
assert (checkMetro (AREA("a", AREA("b", CONNECT(STATION "a", STATION "b"))) ));
assert (checkMetro (AREA("a", CONNECT(STATION "a", AREA("b", STATION "a"))) ));
assert (checkMetro ( CONNECT (AREA ("a", STATION "a"), AREA ("b", AREA("a", CONNECT(STATION "b", STATION "a")))) ));

assert (not (checkMetro (AREA("a", STATION "b") )));
assert (not (checkMetro (AREA("a", CONNECT(STATION "a", AREA("b", STATION "c"))) )));
assert (not (checkMetro (AREA("a", AREA("b", CONNECT(STATION "a", STATION "c"))) )));
assert (not (checkMetro ( CONNECT (AREA ("c", STATION "c"), AREA ("b", AREA("a", CONNECT(STATION "b", STATION "c")))) )));
;;


(*
 * Homework 3
 *)


(*
 * Homework 4
 *)


(*
 * Homework 5
 *)


(*
 * Homework 6
 *)


print_string "\x1b[32mALL GREEN! (1)\x1b[0m\n"
