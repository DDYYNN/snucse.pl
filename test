#!/usr/bin/env ruby
require 'diffy'
require 'curses'

#
# Helpers
#
def assert actual; assert_eq actual, true end
def assert_eq actual, expected
  if actual == expected; return end

  Diffy::Diff.default_format = :color
  puts
  puts 'Failed'
  puts " \e[32mEXPECTED\e[0m  \e[31mACTUAL\e[0m"
  puts '-'*40
  puts
  puts Diffy::Diff.new actual, expected
  exit 1
end

class Fixnum
  def digits
    return 1 if self == 0
    Math.log10(self.abs).to_i + 1
  end
end

class Counter
  def initialize win, total
    @win = win
    @format = "%0#{(total - 1).digits}d/#{total}"
    @iter = 0
    @total = total
    @print_length = 0
  end

  def tick
    msg = @format % @iter
    @win << "\b"*@print_length + msg
    @win.refresh

    @iter += 1
    @print_length = msg.length
  end

  def clean
    @win << "\b"*@print_length + ' '*@print_length + "\b"*@print_length
    @win.refresh

    @iter = @total
    @print_length = 0
  end

  def count; return @iter end
end

class TempMsg
  def initialize win, string
    @win = win
    @clean = "\b"*string.length + ' '*string.length + "\b"*string.length

    @win << string
    @win.refresh
  end

  def clean
    @win << @clean
    @win.refresh
  end
end


#
# Tests
#
class Test
  @@tasks = []
  @@pos = 2

  def self.add
    win = Curses::Window.new(1, 0, @@pos, 0)
    @@tasks << Thread.new do
      yield win
    end
    @@pos += 1
  end

  def self.wait
    @@tasks.each { |thr| thr.join }

    win = Curses::Window.new(1, 0, 0, 0)
    win << 'Done!'
    win.getch
  end
end

def kminus win, dirname, ext = 'k-'
  `cd #{dirname} && make 2>/dev/null`
  glob = Dir.glob("#{dirname}/examples/*.out")
  counter = Counter.new win, glob.count
  glob.each_with_index do |name, i|
    code = File.basename(name, '.out')

    input = File.join(dirname, 'examples', File.basename(name, '.out') + '.in')
    actual = unless File.exist?(input)
      `#{dirname}/run #{dirname}/examples/#{code}.#{ext}`
    else
      `#{dirname}/run #{dirname}/examples/#{code}.#{ext} < #{input}`
    end

    expected = File.read(name)

    assert_eq actual, expected
    counter.tick
  end
  counter.clean
  win << 'OK (%d)' % counter.count
  win.refresh
end


Curses.init_screen

Test.add do |win|
  win << 'Homework 1.* 2.* ... '
  win.refresh

  assert system 'ocaml tests/basic.ml'

  win << 'OK'
  win.refresh
end

Test.add do |win|
  win << 'Homework 2.2 ... '
  win.refresh

  assert system 'ocaml tests/hw2-ex2.ml'

  win << 'OK'
  win.refresh
end

Test.add do |win|
  win << 'Homework 2.7 ... '
  win.refresh

  assert_eq `ocaml tests/hw2-ex7.ml`, File.read('tests/hw2-ex7')

  win << 'OK'
  win.refresh
end

Test.add do |win|
  win << 'Homework 3.1 ... '
  win.refresh

  kminus win, 'hw3'
end

Test.add do |win|
  win << 'Homework 3.2 ... '
  win.refresh

  tmp = TempMsg.new win, 'Compiling reference program'
  @exename = "tests/coin"
  system "g++ -std=c++0x -O3 tests/hw3-ex2.cc -o #{@exename}"
  tmp.clean

  tmp = TempMsg.new win, 'Testing '
  try = 120
  counter = Counter.new win, try
  def test num
    assert_eq `echo #{num} | hw3/run hw3/examples/ex2.k-`, `#{@exename} #{num}`
  end

  try -= 1
  counter.tick
  test 10000
  try.times do
    counter.tick
    test rand(1..10000)
  end

  tmp.clean
  counter.clean
  File.delete @exename

  win << 'OK'
  win.refresh
end

Test.add do |win|
  def test name
    code = File.read('hw3/examples/ex3.k-')
    test = File.read("tests/#{name}.k-")

    tmp = 'tests/tmp'
    File.write(tmp, code + ';' + test)
    actual = `hw3/run #{tmp}`
    File.delete tmp

    expected = File.read("tests/#{name}.out")

    assert_eq actual, expected
  end

  win << 'Homework 3.3 ... '
  win.refresh

  test 'hw3-ex3'
  test 'hw3-ex3-TA'

  win << 'OK'
  win.refresh
end

Test.add do |win|
  win << 'Homework 4.2 ... '
  win.refresh

  msg = `cd hw4 && ./test --simple`

  assert $?.success?

  win << msg
  win.refresh
end

#Test.add do |win|
#  win << 'Homework 5.1 ... '
#  kminus win, 'hw5', 'k--'
#end

Test.wait
